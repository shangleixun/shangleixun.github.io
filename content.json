{"meta":{"title":"浅水","subtitle":"一滩浅水的梦，是海洋。","description":"一个普通的 iOS 开发者。","author":"尚雷勋","url":"https://shangleixun.github.io","root":"/"},"pages":[],"posts":[{"title":"在 Swift 中使用 JSON —— 翻译","slug":"在 Swift 中使用 JSON","date":"2020-04-16T02:33:59.000Z","updated":"2020-04-16T02:58:16.181Z","comments":true,"path":"2020/04/16/在 Swift 中使用 JSON/","link":"","permalink":"https://shangleixun.github.io/2020/04/16/在 Swift 中使用 JSON/","excerpt":"","text":"如果你的 app 同一个 web 应用程序进行通信，则从服务器返回的信息常被格式化为 JSON 。 你可以使用 Foundation 框架的 JSONSerialization 类将 JSON 转换为 Swift 数据类型，如 Dictionary，Array，String，Number 和 Bool 等。 但是，因为你不能确定你的 app 接收到的 JSON 的结构或值（是什么样子的），所以正确地反序列化模型对象可能就有些挑战。 本篇博文描述了几种你可以采用的方法，当你在你的 app 中使用 JSON 时。 从 JSON 中提取值JSONSerialization 的类方法 jsonObject(with:options:) 返回类型为 Any 的值，如果数据不能解析，则抛出一个错误。 1234import Foundationlet data: Data // 从网络请求中接收到的数据，比如let json = try? JSONSerialization.jsonObject(with: data, options: []) 虽然有效的 JSON 可能只包含一个值，但来自 web 应用程序的响应通常会将一个对象或数组编码为顶层对象。你可以使用可选绑定和在 if 或 guard 语句中的 as? 类型转换运算符，提取一个已知类型的值为常量。要从一个 JSON 对象类型中获取 Dictionary 值，有条件地将它转换成 [String: Any] 。要从一个 JSON 数组类型中获取 Array 值，有条件地将其转换为 [Any] （或一个有更具体的元素类型的数组，如 [String] ）。 你可以使用带下标访问器的类型转换可选绑定或带枚举的模式匹配，来按键提取字典值或按索引提取数组值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// Example JSON with object root:// 根是对象的 JSON 例子：/* &#123; \"someKey\": 42.0, \"anotherKey\": &#123; \"someNestedKey\": true &#125; &#125;*/if let dictionary = jsonWithObjectRoot as? [String: Any] &#123; if let number = dictionary[\"someKey\"] as? Double &#123; // access individual value in dictionary // 获取字典中的单个的值 &#125; for (key, value) in dictionary &#123; // access all key / value pairs in dictionary // 获取字典中所有的键/值对 &#125; if let nestedDictionary = dictionary[\"anotherKey\"] as? [String: Any] &#123; // access nested dictionary values by key // 用键获取嵌套的字典值 &#125;&#125;// Example JSON with array root:// 根是数组的 JSON 例子：/* [ \"hello\", 3, true ]*/if let array = jsonWithArrayRoot as? [Any] &#123; if let firstObject = array.first &#123; // access individual object in array // 获取数组中的单个的值 &#125; for object in array &#123; // access all objects in array // 获取字典中所有的对象 &#125; for case let string as String in array &#123; // access only string values in array // 只获取字典中的 String 值 &#125;&#125; Swift 的内建语言功能使安全地提取和使用 JSON 数据变得简单 —— 用 Foundation 的 API 来解码而无需外部的库或框架。 使用从 JSON 提取的值创建 model 对象因为大多数的 Swift app 遵循 Model-View-Controller 的设计模式，通常来说，将 JSON 数据转换为适用于你的 app 的域的 model 定义的对象，是有用的。 比如，当编写一个提供本地的餐馆的搜索结果的 app ，你可能会实现一个 Restaurant 的 model ，它有一个初始化器，接收 JSON 对象，且有一个类方法来向服务器的 /search 端点做 HTTP 请求，然后异步地返回一个（元素是） Restaurant 对象的数组。考虑下面的 Restaurant model： 123456789101112import Foundationstruct Restaurant &#123; enum Meal: String &#123; case breakfast, lunch, dinner &#125; let name: String // 注：这里应该是 coordinate ，因为下文赋值时，并没有使用 location let location: (latitude: Double, longitude: Double) let meals: Set&lt;Meal&gt;&#125; Restaurant 有一个类型为 String 的 name ，一个表示坐标对的 location ，和一个名为 meals 的 Set 包含着嵌套的 Meal 枚举。这里有一个例子，单一的 restaurant 如何在服务器的响应里面呈现的： 12345678&#123; \"name\": \"Caffè Macs\", \"coordinates\": &#123; \"lat\": 37.330576, \"lng\": -122.029739 &#125;, \"meals\": [\"breakfast\", \"lunch\", \"dinner\"]&#125; 编写一个可选的 JSON 初始化器要从 JSON representation （意思是表述，表现）转换为 Restaurant 对象，（需要）写一个初始化器，带一个从 JSON representation 提取和转换数据到属性值中的 Any 形参： 12345678910111213141516171819202122232425extension Restaurant &#123; init?(json: [String: Any]) &#123; guard let name = json[\"name\"] as? String, let coordinatesJSON = json[\"coordinates\"] as? [String: Double], let latitude = coordinatesJSON[\"lat\"], let longitude = coordinatesJSON[\"lng\"], let mealsJSON = json[\"meals\"] as? [String] else &#123; return nil &#125; var meals: Set&lt;Meal&gt; = [] for string in mealsJSON &#123; guard let meal = Meal(rawValue: string) else &#123; return nil &#125; meals.insert(meal) &#125; self.name = name self.coordinates = (latitude, longitude) self.meals = meals &#125;&#125; 如果你的 app 和一个或多个 web 服务器通信，返回的并不是一个单一的，不变的 model 对象的 representation ，考虑实现多个初始化器来处理每个可能的 representation 。上面的例子中，从传进来的 JSON 字典中提取出来的每个常量值，都使用了可选绑定和 as? 类型转换运算符。对 name 属性，提取出来的 name 值简单地标记为 as-is 。对 coordinate 属性，提取出来的 latitude 和 longitude 值在赋值之前，组合成了一个元组。对 meals 属性，提取出来的字符串值被遍历以构造一个（元素是） Meal 枚举值的 Set 。 编写一个带有错误处理的 JSON 的初始化器前面的例子实现了一个可选初始化器，如果反序列化失败则返回 nil 。再一个，你可以定义一个遵照 Error 协议的类型，然后实现一个初始化器，在反序列化失败时抛出一个那个类型的错误。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849enum SerializationError: Error &#123; case missing(String) case invalid(String, Any)&#125;extension Restaurant &#123; init(json: [String: Any]) throws &#123; // Extract name // 提取 name guard let name = json[\"name\"] as? String else &#123; throw SerializationError.missing(\"name\") &#125; // Extract and validate coordinates // 提取并验证 coordinates guard let coordinatesJSON = json[\"coordinates\"] as? [String: Double], let latitude = coordinatesJSON[\"lat\"], let longitude = coordinatesJSON[\"lng\"] else &#123; throw SerializationError.missing(\"coordinates\") &#125; let coordinates = (latitude, longitude) guard case (-90...90, -180...180) = coordinates else &#123; throw SerializationError.invalid(\"coordinates\", coordinates) &#125; // Extract and validate meals // 提取并验证 meals guard let mealsJSON = json[\"meals\"] as? [String] else &#123; throw SerializationError.missing(\"meals\") &#125; var meals: Set&lt;Meal&gt; = [] for string in mealsJSON &#123; guard let meal = Meal(rawValue: string) else &#123; throw SerializationError.invalid(\"meals\", string) &#125; meals.insert(meal) &#125; // Initialize properties // 初始化（本类的）属性 self.name = name self.coordinates = coordinates self.meals = meals &#125;&#125; 这里，Restaurant 类型声明了一个嵌套的 SerializationError 类型，它定义了几个跟值的丢失或无效的属性相关联的枚举 case 。在有 throwing 版本的 JSON 的初始化器中，不同于通过返回 nil 来表明失败，其抛出的错误都会传达具体的失败（原因）。这个版本也执行了对输入数据的有效验证来确保 coordinates 代表一个有效的地理坐标对，JSON 中\b具体指明的 meals 的每个名称，和 Meal 的枚举 case 相对应。 编写一个类方法来接取结果Web 应用程序端点经常在单个的 JSON 响应中返回多个资源。举例来说，一个 /search 端点可能返回〇个或多个 restaurant ，以匹配请求的\b查询参数，包括这些附加了其他元数据的 representation ： 12345678910111213141516&#123; \"query\": \"sandwich\", \"results_count\": 12, \"page\": 1, \"results\": [ &#123; \"name\": \"Caffè Macs\", \"coordinates\": &#123; \"lat\": 37.330576, \"lng\": -122.029739 &#125;, \"meals\": [\"breakfast\", \"lunch\", \"dinner\"] &#125;, ... ]&#125; 你可以在 Restaurant 结构体中创建一个类方法，将 query 方法的参数转换成对应的请求对象，然后发送 HTTP 请求到 web 服务（端点）。这段代码也负责处理响应，反序列化 JSON 数据，用 &quot;results&quot; 数组中提取出来的字典创建 Restaurant 对象，并且在完成的 handler 中异步地返回它们。 1234567891011121314151617181920212223242526extension Restaurant &#123; private let urlComponents: URLComponents // base URL components of the web service private let session: URLSession // shared session for interacting with the web service static func restaurants(matching query: String, completion: ([Restaurant]) -&gt; Void) &#123; var searchURLComponents = urlComponents searchURLComponents.path = \"/search\" searchURLComponents.queryItems = [URLQueryItem(name: \"q\", value: query)] let searchURL = searchURLComponents.url! session.dataTask(url: searchURL, completion: &#123; (_, _, data, _) var restaurants: [Restaurant] = [] if let data = data, let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] &#123; for case let result in json[\"results\"] &#123; if let restaurant = Restaurant(json: result) &#123; restaurants.append(restaurant) &#125; &#125; &#125; completion(restaurants) &#125;).resume() &#125;&#125; 当用户在搜索 bar 中输入文本时，\b视图控制器就能调用这个方法，来填入（populate）一个列表视图——其中是匹配的餐馆。 123456789101112import UIKitextension ViewController: UISearchResultsUpdating &#123; func updateSearchResultsForSearchController(_ searchController: UISearchController) &#123; if let query = searchController.searchBar.text, !query.isEmpty &#123; Restaurant.restaurants(matching: query) &#123; restaurants in self.restaurants = restaurants self.tableView.reloadData() &#125; &#125; &#125;&#125; 用这种关注点分离的方式，在视图控制器中提供了一个恒定不变的界面来获取餐馆资源，即便 web 服务中的实现细节变化时。 对反射机制的反思为了在不同的系统中进行通信，把同样的数据转换成各种 representation ，对编写软件来说，是一件繁琐但却有必要的任务。因为这些 representation 的结构可能是很类似的，那就也许会尝试来创建一个更高层级的抽象（策略），以在这些不同的 representation 之间自动地映射。比方说，有一个类型可能定义了一种映射关系，在 snake_case 的 JSON 键值和 camelCase 的属性名称之间，以使用 Swift 的反射 API ——如 Mirror ——自动地从 JSON 初始化一个 model 。然而，我们发现，同使用 Swift 语言功能的常规用法相比，这类抽象（策略）并不倾向于能提供可观的好处，反而使得调试问题或处理极端情况变得更难。在上面的例子中，初始化器不仅从 JSON 提取并映射了值，也初始化了复杂的数据类型并且执行了具体域的输入有效性验证。基于反射机制的方法可能得费尽周折才能完成所有的这些任务。当为你自己的 app 评估可用的策略时，请记住这一点。少量的重复所花费的成本可能远少于挑选了不正确的抽象（策略）。 译自苹果官方 Swift blog，原博文发布日期：二〇一六年九月十二日。 二〇年四月十五日 1411","categories":[],"tags":[{"name":"swift","slug":"swift","permalink":"https://shangleixun.github.io/tags/swift/"}]},{"title":"FFmpeg sws_scale 函数介绍 —— 翻译","slug":"sws_scale 函数介绍","date":"2019-10-31T09:06:00.000Z","updated":"2020-04-16T03:17:06.137Z","comments":true,"path":"2019/10/31/sws_scale 函数介绍/","link":"","permalink":"https://shangleixun.github.io/2019/10/31/sws_scale 函数介绍/","excerpt":"","text":"sws_scale 介绍 摘自 FFmpeg 4.2.1名称翻译：stride 宽距 /** Scale the image slice in srcSlice and put the resulting scaled slice in the image in dst. A slice is a sequence of consecutive rows in an image. 把图像片 scale 成 srcSlice ，尔后将 scale 过的图像中的片放进 dst 数组中。片是图像中连续的有次序的行。 * Slices have to be provided in sequential order, either in top-bottom or bottom-top order. If slices are provided in non-sequential order the behavior of the function is undefined. slices 必须以连续的次序，——从顶到底或由底到顶的次序来提供。如果提供的切片是非连续的次序，则本函数的行为是不明确的。 * @param c the scaling context previously created with sws_getContext() 在先通过 sws_getContext() 创建的 scaling 上下文 @param srcSlice the array containing the pointers to the planes of the source slice 包含着源切片的平面的指针的数组 @param srcStride the array containing the strides for each plane of the source image 包含着源图片每个平面的宽距的数组 @param srcSliceY the position in the source image of the slice to process, that is the number (counted starting from zero) in the image of the first row of the slice 要处理的在源图像中的切片的位置，此为图像中切片的第一行的 number （从〇开始数起） @param srcSliceH the height of the source slice, that is the number of rows in the slice 源切片的高度，即切片中的行数 @param dst the array containing the pointers to the planes of the destination image 包含着目标图像的平面的指针的数组 @param dstStride the array containing the strides for each plane of the destination image 包含着目标图像中每一个平面的宽距的数组 @return the height of the output slice 输出的切片的高度 */int sws_scale(struct SwsContext *c, const uint8_t *const srcSlice[], const int srcStride[], int srcSliceY, int srcSliceH, uint8_t *const dst[], const int dstStride[]);","categories":[],"tags":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://shangleixun.github.io/tags/ffmpeg/"}]},{"title":"一道排列组合题的诞生及解决","slug":"A 到 B 点之间一共有几种走法","date":"2019-09-22T07:59:00.000Z","updated":"2020-04-16T02:32:44.659Z","comments":true,"path":"2019/09/22/A 到 B 点之间一共有几种走法/","link":"","permalink":"https://shangleixun.github.io/2019/09/22/A 到 B 点之间一共有几种走法/","excerpt":"","text":"这道题目是面试的最后，一位老板出给我的，我想了半天，只想到这可能需要二叉树的相关知识，而我对二叉树并不熟悉，只好放弃解答。面试的结果已经不重要了（没有写出来，一定是面试不成功啦），但这道题却困扰了我相当几天时间。后来好在想通了解答之法。 题目的具体内容是这样的：A 点的坐标位置为原点，B 点坐标位置为 (4, 4) ，从 A 点出发到 B 点，每次只能向上或向右走一步，问：有几种走法？这种类型的题我没有遇见过，开始只想到二叉树，后来发现用我现有的二叉树知识无法解答。 在前两天的夜里，我拿出本子和笔，打算用演算来解决它。A 点的坐标自然是 (0, 0) ，要达到 (4, 4) ，则有无数种方法。但通过 x 坐标和 y 坐标递增 1 的方式来实现，则是可数的，x 坐标的过程是：x+1 ，x+2 ，x+3 ，x+4 ，同样的，y 坐标的过程是：y+1 ，y+2 ，y+3 ，y+4 。为了方便后面谈到，我们把 x+1…x+4 和 y+1…y+4 分别用 A B C D 和 a b c d 来替代。x 坐标要经过四步到达目标，y 坐标同样是四步。不过两个步骤可以穿插进行，也就是 A B C D 中间可以随意插入 a b c d 的组合——既可以是 abcd 连在一起，也可以是 ab cd 这样分成两部分的形式。 那么问题简化而成的模型就是这样了：有两个序列 A B C D 和 a b c d 。在保证两个序列固定（即 B 必须在 A 之后，其他同理）的前提下，有几种排列组合？我不知道怎么用程序的算法来实现，我想了很久都不知道，于是我只好用一个笨方法来做，一个一个排列。 设定 A B C D 序列固定，在四个字母之间，一共有五个空隙，就当作五个箱子。穷举 a b c d 的所有组合，然后遍历每种组合，看本组合放进五个箱子的情况有多少种，将遍历的每个组合的“情况”加和，就得到了结果。其实读者可以自己去试一试，不过，我今天比较闲，就在这里遍历一下，一起看看罢。 第一种：abcd 。这种情况很好处理，整体一块，五个箱子，也就只有五种情况了，所以这种组合的“情况”数量为 5 。第二种：abc d 和 a bcd 。这是分成两块的第一种情况。两个桃子放五个箱子，有 5×4 种情况，但两个桃子是固定序列，必须是 abc 在前，d 在后，所以还要除以所有的序列可能，即 2! ，这样得到 abc d 的“情况”数量为：5×4 / 2! ，还有一个 a bcd 和它是一样的，所以第二种的所有“情况”数量应为：5×4 / 2!×2 = 20 。第三种：ab cd 。这是分成两块的第二种情况，是上面数量的一半，所以数量为 10 。第四种：ab c d 和 a bc d 和 a b cd 。三个桃子放进五个箱子，有 5×4×3 种情况，除以序列的可能 3! ，是 10 ，有三种，所以是 30 。第五种：a b c d 。这是全分离。四个桃子放五个箱子，有 5×4×3×2 种情况，除以序列可能 4! ，是 5 。这是所有的组合了，加和一下：5 + 20 + 10 + 30 + 5 = 70 。 实际上的答案也是这样的，正是 70 种。但我一想，这里面有一个东西是我所不熟悉的，就是找出一个整数分成大于 1 的整数的加和的组合的个数。我一时也想不到方法来求出。这还只是 4 ，如果是 100 ，我不就没办法解决了吗？所以还是要找出简便的方法来。 其实简便的方法已经在上面有用到了，就是在乱序中找出固定序列的个数的方法。现在将 A B C D a b c d 当作八个元素，随意组合，则根据初中学到的排列组合的知识，有 8! 种组合。先不管 a b c d 在其中是如何排列的，A B C D 的序列是一定有 4! 种可能的，它包含了 A B C D 的所有组合，即 AB CD （或者 DC BA ） 或者 ABCD （或者 DCBA ）这样的。那么固定序列 A B C D 在其中的占比，则是 4! 分之一。所以在 8! 中，固定序列 A B C D 的数量就容易求出来了：8! / 4! 。除了 A B C D ，还有 a b c d 的固定序列。所以，在 8! / 4! 的基础上，再除以 4! 即可。答案应该是：8! / (4!×4!) = 70 。 有了这种解法，就可以举一反三，如果 B 点坐标是 (5, 9) ，规则一致，则走法的数量就是：14! / (5!×9!) ；其他同理。 假设 A 点坐标为 (x1, y1) ，B 点坐标为 (x2, y2) ，x2-x1 和 y2-y1 均为正整数，从 A 点到达 B 点，每次只能向上或向右前进一个单位，则共有 (x2-x1+y2-y1)! / ((x2-x1)!×(y2-y1)!) 种可能。 这类问题的实际意义我还不太知道；就它的解法，我只能想到这些了，这篇文字也该在这里收束了。 九月廿二日 1559","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://shangleixun.github.io/tags/algorithm/"}]},{"title":"简明的 GitHub 个人博客搭建教程","slug":"简明的 GitHub 个人博客搭建教程","date":"2019-09-05T10:05:00.000Z","updated":"2020-04-16T02:32:41.694Z","comments":true,"path":"2019/09/05/简明的 GitHub 个人博客搭建教程/","link":"","permalink":"https://shangleixun.github.io/2019/09/05/简明的 GitHub 个人博客搭建教程/","excerpt":"","text":"心血来潮，终于想依托 GitHub 创建一个个人博客网站。想到之前看过的教程，感觉头皮发麻，有一丝胆怯，最后硬着头皮做了下来。结果差强人意，不过是可以来写博客了而已。 总体上来说，分三步： 第一步：在 GitHub 上建立专门为博客网站的 repo 。流程极简单，在 GitHub 个人主页，创建新的 repo ，有一点要注意，如果是第一次创建 *.github.io 类的 repo ，repo name 必须以用户名为前缀，不然会失败。repo 的名称应该是：username.github.io 。其他默认就好了。 第二步：在电脑上安装 Node.js ，Git ，以及 Hexo 。使用 macOS 的用户，应该是极方便的，只用安装 Node.js 就可以了。安装方法，我是直接在官网下载稳定包，安装就完事。安装 Hexo 的命令如下： 1$ npm install -g hexo-cli macOS 如果提示没有写入权限，可以用 1$ sudo chown -R $USER /usr/local 来获取 /usr/local 目录的写入权限。 第三步：在电脑端创建新的空文件夹，并使用 Hexo 初始化。到这里要停一下，因为我在这里吃了苦头，后来导致重来一遍。在电脑上，建立一个 username.github.io 的文件夹（其实名称不重要，关键是见名知义）。打开终端，进入当前文件夹。执行 1$ hexo init // 此命令必须在新的空文件夹中执行。 的命令。这个命令执行完成后，打开文件夹查看，里面会有好几个文件夹，和一些零散的文件，目前你只需要关注一个叫做 _config.yml 的文件，它在根目录中，它的相关配置决定了稍后你能否将本地内容推送到远程的 username.github.io 仓库，并且在 username.github.io 这个网页中，打开查看 Hexo 默认为你的博客撰写的一条叫 hello world 的博文。 打开 _config.yml ，在最下方的 deploy 处，修改 type 为 git ，另外添加两个字段：repo: https://github.com/username/username.github.io.git 及branch: master 。 然后执行这个命令，安装布署工具： 1$ npm install hexo-deployer-git --save 再执行下面三条命令： 123$ hexo clean // 清理。$ hexo g // g 是 generate 的缩写。$ hexo d // d 为 deploy 的缩写。 在执行布署命令时，会要求你输入你的 GitHub 用户名和密码，直接输入就好了。布署成功后，你应当就可以在 username.github.io 中看到 Hexo 为你撰写的默认博文 hello world 了。 Hexo 的配置之类，是很丰富的，可查看参阅的第二条链接。 参阅：1 GitHub Pages；2 Hexo 官方中文文档；3 史上最详细的 Hexo 博客搭建图文教程；4 GitHub+Hexo 搭建个人网站详细教程（本链接强烈推荐，细致、有效）。 九月五日 1804","categories":[],"tags":[{"name":"blog","slug":"blog","permalink":"https://shangleixun.github.io/tags/blog/"}]}]}